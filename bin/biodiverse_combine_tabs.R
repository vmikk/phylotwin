#!/usr/bin/env Rscript

## Combine Biodiverse results (multiple tables) into a single table

## NB. It's important to specify the same H3 resolution as used in input data for Biodiverse
##     otherwise (if higher resolution is specified), there might be grid cells with identical H3 codes
##     and the results will be merged incorrectly.



## Biodiverse outputs:
# 1. `groups` - species table (rows = sites, columns = species)
# 
# 2. `SPATIAL_RESULTS` contains the observed results for each group (cell)
#
# 3. `rand--SPATIAL_RESULTS` contains indices to track the randomisations for each index in SPATIAL_RESULTS
#    For example, for `PE_WE` there will be `C_PE_WE`, `Q_PE_WE`, `T_PE_WE` and `P_PE_WE` collating, respectively, 
#    the number of times observed `PE_WE` was higher than that generated using the randomised data, 
#    the number of times observed `PE_WE` was compared against the scores from the randomised data, 
#    the number of times the observed and random scores were tied, 
#    and the proportion of iterations that the observed score was higher than the random scores (P_PE_WE = C_WE_PE / Q_PE_WE).
#
#  Indices are prefixed by a letter with an underscore
#   C_* (e.g. `C_ENDC_CWE`, `C_NUM_MAX`) is the number of times the original value was higher than the comparison.
#   Q_* (e.g. `Q_ENDC_CWE`, `Q_NUM_MAX`) is the number of comparisons (q = quantum). We could use the number of iterations directly, however there may be cases where undefined values result for some indices. We cannot compare undefined with a number, and we also cannot be sure that the number of times undef results is the same for all indices.
#   P_* (e.g. `P_ENDC_CWE`, `P_NUM_MAX`) is the fractional ranking of the original value against those generated by the set of randomisations, calculated as C_* / Q_*. Multiply by 100 to get a percentile. The P_* score can be converted into a p-score in the normal way, i.e. if P_* = 0.99 then the original measure is higher than the randomised versions 99 times out of every hundred. If one considers higher scores to be more significant (a one tailed test) then this is the same as a p score of 0.01. One-tailed tests for low values need to account for any ties (see next point) to get the correct rank, but the interpretation is then the same. Obviously one changes the interpretation appropriately if it is a two tailed system, e.g. the mean of numeric labels (NUM_MEAN) can be higher or lower than the set of randomisation results. So long as it is in one of the tails of the distribution then the original result is significantly more extreme than that generated by the randomisation (e.g. (C_NUM_MEAN + T_NUM_MEAN) / Q_NUM_MEAN < 0.025 or P_NUM_MEAN > 0.975 for an alpha of 0.05).
#   T_* (e.g. `T_ENDC_CWE`, `T_NUM_MAX`) is the number of ties, being the count of the number of times the original value was the same as the randomised value. If there were no ties then this index is not listed.
#   SUMX_* and SUMXX_* (e.g. `SUMX_ENDC_CWE`, `SUMXX_NUM_MAX`) are the sums and sums of squared values for the random indices. These are used to calculate z-scores of the distributions as an alternative to the rank relative scoring system
#
# 4. `--z_scores--SPATIAL_RESULTS`
#    Standardised effect sizes (z-scores) for the observed results

# 5. `rand--p_rank--SPATIAL_RESULTS` contains a set of results using the same names as the original indices in SPATIAL_RESULTS,
#    but converted to their rank relative positions.  
#    Importantly, the lower tail ranks take into account any ties in the comparisons, thus simplifying any code that uses theses results.
#    Also, any value that would be considered not significant at alpha=0.05 (one tailed, high or low) is converted to undef (null).
#    This makes any plots of the results clearer within Biodiverse so one can more easily see which groups would pass a one-tailed high or low test.
#
# 6. `rand--CANAPE--`
#    CANAPE_CODE            = code of endemism type
#    MIXED,NEO,PALAEO,SUPER = binary
#
# 7. `HURLBERT_ES`, and `rand--HURLBERT_ES` + `rand--p_rank--HURLBERT_ES` + `--z_scores--HURLBERT_ES`
#    Series of Hurlbert's ES index for various values of N (column names: `5`, `10`, `20`, `50`, `100`, `200`)
#    files are analogous to SPATIAL_RESULTS


## Z-score formula derivation:
# xm = mean(xi)
# var = 1/N * sum(xi - xm)^2 = 1/N * sum(xi^2 - 2*xm*xi + xm^2) = 
#     = 1/N * sum(xi^2) - 2*xm*[ 1/N * sum(xi) ] + xm^2 = 
#     = 1/N * sum(xi^2) - 2*(xm^2) + xm^2 = 
#     = 1/N * sum(xi^2) - xm^2
#
# SUMX = sum(xi); SUMXX = sum(xi^2)
# xm = SUMX / N
# sd = sqrt( SUMXX/N  - (SUMX/N)^2 )
# z  = (obs - xm) / sd  = (obs -  SUMX/N) / sd

## Z-score interpretation:
# the values outside the interval [-1.96,1.96] being significant for two tailed test with an alpha of 0.05, providing the number of samples is large. 

cat("Combining Biodiverse results\n")

## Function to load packages
load_pckg <- function(pkg = "data.table"){
    suppressPackageStartupMessages( library(package = pkg, character.only = TRUE) )
    cat(".. ", paste(pkg, packageVersion(pkg), "\n"))
}

cat("Loading packages:\n")
load_pckg("optparse")
load_pckg("data.table")
load_pckg("h3")

cat("\n Parsing command line arguments\n")

## Define the option parser
option_list <- list(
    ## Input-output parameters
    make_option(c("-i", "--inpdir"), type = "character", default = ".",   help = "Input directory"),
    make_option(c("-p", "--prefix"), type = "character", default = "RND", help = "Biodiverse prefix of intput files"),
    make_option(c("-r", "--resolution"), action="store", default=4, type='integer', help="H3 resolution (e.g., 4)"),
    make_option(c("-o", "--output"), type = "character", default = "Biodiverse_results.txt", help = "Output file name")
)

## Parse the command line arguments
opt <- parse_args(OptionParser(option_list = option_list))
# print(opt)

## Validation of the required arguments
if(is.na(opt$inpdir)){ cat("Input directory is not specified.\n", file=stderr()); stop() }
if(is.na(opt$output)){ cat("Output prefix is not specified.\n", file=stderr()); stop() }
if(is.na(opt$resolution)){ cat("H3 resolution is not specified.\n", file=stderr()); stop() }
if(opt$resolution < 1 || opt$resolution > 15){ cat("H3 resolution must be between 1 and 15.\n", file=stderr()); stop() }


## Input parameters
INPDIR     <- opt$inpdir
PREFIX     <- opt$prefix
RESOLUTION <- opt$resolution
OUTPUT     <- opt$output


##########################################################
########################################################## Taxonomy-based filters
##########################################################



cat("\n\n-------- Loading Biodiverse results --------\n\n")

## Function to read Biodiverse results
read_bd <- function(file){
  
  res <- fread(file, sep = ",")
  
  ## ELEMENT = concatenated coords 20.4069805389076:68.992705038507
  res[, ELEMENT := NULL]
  
  setnames(res,
    old = c("Axis_1", "Axis_0"),
    new = c("Latitude", "Longitude"))
  
  res[ , H3 := h3::geo_to_h3(res[, .(Latitude, Longitude)], res = RESOLUTION) ]
  res[ , c("Latitude", "Longitude") := NULL ]
  setcolorder(res, "H3")

  return(res)
}

## Get the list of tables from Biodiverse
fls <- list.files(
  path = INPDIR,
  pattern = paste0(PREFIX, "_.*\\.csv$"),
  full.names = TRUE, recursive = FALSE, include.dirs = FALSE)


## Initialize the list of results
RES <- list()

## Observed diversity values - RND_SPATIAL_RESULTS.csv
fl_obs <- file.path(INPDIR, paste0(PREFIX, "_SPATIAL_RESULTS.csv"))
if(fl_obs %in% fls){
  cat("..Observed indices\n")
  RES$obs <- read_bd(fl_obs)
}

## SES-scores - RND_rand--z_scores--SPATIAL_RESULTS.csv
fl_ses <- file.path(INPDIR, paste0(PREFIX, "_rand--z_scores--SPATIAL_RESULTS.csv"))
if(fl_ses %in% fls){
  cat("..SES-scores\n")
  RES$ses <- read_bd(fl_ses)

  ## Rename columns
  s_cols <- colnames(RES$ses)[ ! colnames(RES$ses) %in% "H3" ]
  setnames(
    x   = RES$ses,
    old = s_cols,
    new = paste0(s_cols, "__SES"))
  rm(s_cols)
}

## P-values - RND_rand--p_rank--SPATIAL_RESULTS.csv
fl_p <- file.path(INPDIR, paste0(PREFIX, "_rand--p_rank--SPATIAL_RESULTS.csv"))
if(fl_p %in% fls){
  cat("..P-values\n")
  RES$p <- read_bd(fl_p)

  ## Rename columns
  p_cols <- colnames(RES$p)[ ! colnames(RES$p) %in% "H3" ]
  setnames(
    x   = RES$p,
    old = p_cols,
    new = paste0(p_cols, "__Pvalue"))
  rm(p_cols)
}

## CANAPE results - RND_rand--CANAPE--.csv
fl_canape <- file.path(INPDIR, paste0(PREFIX, "_rand--CANAPE--.csv"))
if(fl_canape %in% fls){
  cat("..CANAPE\n")
  RES$canape <- read_bd(fl_canape)

  ## Parse codes
  RES$canape[ , CANAPE := fcase(
    CANAPE_CODE == 0, "non-significant",
    CANAPE_CODE == 1, "NEO",
    CANAPE_CODE == 2, "PALAEO",
    CANAPE_CODE == 3, "MIXED",
    CANAPE_CODE == 4, "SUPER"
    ) ]

  RES$canape[ , c("CANAPE_CODE", "MIXED", "NEO", "PALAEO", "SUPER") := NULL ]
}





## Merge the data into a single table
cat("\n\n-------- Merging data into a single table --------\n\n")

merge_dt <- function(x,y){ merge(x, y, by = "H3", all.x = TRUE) }

RESULTS <- Reduce(f = merge_dt, x = RES)

## Export the results
cat("Exporting the results\n")
fwrite(x = RESULTS, file = OUTPUT, sep = "\t")

cat("Done\n")
